# ch02. 객체지향 프로그래밍
p38
'영화': 영화에 대한 기본 정보
    - 제목, 상영시간, 가격 정보와 같이 영화가 가지고 있는 기본적인 정보
'상영': 실제로 관객들이 영화를 관람하는 사건
    - 상영 일자, 시간, 순번  실제로 관객들이 영화를 관람하는 사건을 표현
    
할인액 결정하는 규칙 2가지
'할인 조건': 가격의 할인 여부를 결정  
    - '순서 조건'
    - '기간 조건'
    
'할인 정책': 할인 요금을 결정
    - 금액 할인 정책: 예매 요금에서 일정 금액을 할인해주는 방식
    - 비율 할인 정책: 정가에서 일정 비율의 요금을 할인해주는 방식
    
할인을 적용하기 위해서 할인 조건, 할인 정책을 함께 조합해서 사용

p41
진정한 객체지향 패러다임으로의 전환은 클래스가 아닌 객체에 초점을 맞출 때에만 얻을 수 있다.
-> 이를 위해서는 프로그래밍하는 동안 다음의 두 가지에 집중해야 한다.
1. 어떤 클래스가 필요한지를 고민하기 전에 어떤 객체들이 필요한지 고민하자.
    - 객체를 중심에 두는 접근 방법은 설계를 단순하고 깔끔하게 만든다.
2. 객체를 독립적인 존재가 아니라, 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야 한다.
- 객체들의 모양과 윤곽이 잡히면, 공통된 특성과 상태를 가진 객체들을 타입으로 분류하자.
-> 이 타입을 기반으로 클래스를 구현하자.

p43
클래스를 구현하거나 다른 개발자에 의해 개발된 클래스를 사용할 때, 가장 중요한 것?
- 클래스의 경계를 구분짓는 것

훌륭한 클래스를 설계하기 위한 핵심
- 어떤 부분을 외부에 공개하고 어떤 부분을 감출지 결정하는 것
- 외부에서는 객체의 속성에 직접 접근할 수 없도록 막고,
적절한 public 메서드를 통해서만 내부 상태를 변경할 수 있게 해야 한다.

경계의 명확성이 자율성을 보장한다.

p44
캡슐화: 데이터와 기능을 객체 내부로 함께 묶는 것
접근 제어(access control) 메커니즘 제공

객체지향의 핵심
: 스스로 상태를 관리, 판단, 행동하는 자율적인 객체들의 공동체를 구성하는 것

캡슐화의 접근 제어
- `퍼블릭 인터페이스(public interface)`: 외부에서 접근 가능한 부분
- `구현(implementation)`: 외부에서 접근 불가능, 오직 내부에서만 접근 가능한 부분


`인터페이스와 구현의 분리(separation of interface and implementation)` 원칙

일반적으로 객체의 상태는 숨기고, 행동만 외부에 공개해야 한다. 
- ex) 클래스의 속성은 private으로 선언해서 감추고, 외부에 제공해야 하는 일부 메서드만 public으로 선언한다.
   
p45
`구현은닉(implementation hiding)`

접근 제어 메커니즘: 클래스의 내부와 외부를 명확하게 경계 지을 수 있게 하는 동시에
클래스 작성자가 내부 구현을 은닉할 수 있게 해준다.

클래스를 개발할 때마다 인터페이스와 구현을 깔끔하게 분리하기 위해 노력해야 한다.

설계가 필요한 이유: 변경을 관리하기 위한 것

`접근 제어`

p55
- `오버라이딩(overriding)`
    > 부모 클래스에 정의된 같은 이름, 같은 파라미터 목록을 가진 메서드를 자식 클래스에서 재정의하는 경우
    - 자식 클래스의 메서드는 오버라이딩한 부모 클래스의 메서드를 가리기 때문에 
    -> 외부에서는 부모 클래스의 메서드가 보이지 않는다. 
                        
- `오버로딩(overloading)`
    > 메서드의 이름은 같지만, 제공되는 파라미터의 목록이 다르다.
    - 오버로딩한 메서드는 원래의 메서드를 가리지 않기 때문에 
    -> 이 메서드들은 사이좋게 공존한다.
    ex) 오버로딩의 예
    ```java
    import java.math.BigDecimal;public class Money {
      public Money plus(Money amount) {
          return new Money(this.amount.add(amount.amount));
      } 
      public Money plus(long amount) {
          return new Money(this.amount.add(BigDecimal.valueOf(amount)));
      }
    }
    ```
p59
코드의 의존성과 실행 시점의 의존성이 서로 다를 수 있다.
(클래스 사이의 의존성과 객체 사이의 의존성은 동일하지 않을 수 있다.)
유연하고, 쉽게 재사용할 수 있으며, 확장 가능한 객체지향 설계가 가지는 특징은
코드의 의존성과 실행 시점의 의존성이 다르다는 것이다.

코드의 의존성과 실행 시점의 의존성이 다르면 다를수록 코드를 이해하기 어려워진다.

p61
어떤 클래스를 기준으로 하느냐에 따라 상속 관계에 참여하는 클래스의 역할이 달라진다.

인터페이스는 객체가 이해할 수 있는 메시지의 목록을 정의한다.

p62
자식 클래스는 상속을 통해 부모 클래스의 인터페이스를 물려받는다.
    -> 부모 클래스 대신 사용될 수 있다.
컴파일러는 코드 상에서 부모 클래스가 나오는 모든 장소에서 자식 클래스를 사용하는 것을 허용한다.

p63
다형성: 실제로 어떤 메서드가 실행될 것인지는 메시지를 수신하는 객체의 클래스가 무엇이냐에 따라 달라진다.

다형성은 객체지향 프로그램의 컴파일 시간 의존성과 실행 시간 의존성이 다를 수 있다는 사실을 기반으로 한다.

- 컴파일 시간 의존성: Movie -> DiscountPolicy
- 실행 시간 의존성: Movie -> AmountDiscountPolicy or PercentDiscountPolicy

다형성이란? 동일한 메시지를 수신했을 때, 객체의 타입에 따라 다르게 응답할 수 있는 능력을 의미한다.
-> 다형적인 협력에 참여하는 객체들: 모두 같은 메시지를 이해할 수 있어야 한다.
-> 인터페이스가 동일해야 한다.

다형성을 구현하는 방법
 : 다양하지만, 메시지에 응답하기 위해 실행될 메서드를 컴파일 시점이 아닌 실행 시점에 결정한다는 공통점이 있다.

클래스를 상속받는 것만이 다형성을 구현할 수 있는 유일한 방법은 아니다.


p64
구현 상속 VS 인터페이스 상속
구현 상속: 서브클래싱    
    - 순수하게 코드를 재사용하기 위한 목적
    
인터페이스 상속: 서브타이핑
    - 다형적인 협력을 위해 부모 클래스와 자식 클래스가 인터페이스를 공유할 수 있도록 상속을 이용하는 것
    
상속은 구현 상속이 아니라, 인터페이스 상속을 위해 사용해야 한다.
인터페이스를 재사용할 목적이 아니라, 구현을 재사용할 목적으로 상속을 사용하면,
변경에 취약한 코드를 낳게 될 확률이 높다.

p65
추상화를 이용한 설계는 필요에 따라 표현의 수준을 조정하는 것을 가능하게 해준다.
추상화를 이용해 상위 정책을 기술한다는 것?
기본적인 애플리케이션의 협력 흐름을 기술한다는 것을 의미
