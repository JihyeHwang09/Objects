(p14 ~ p15)
## 로버트 마틴
- 모듈: 크기와 상관 없이 클래스와 패키지, 라이브러리와 같이 프로그램을 구성하는 임의의 요소를 의미

- 모듈의 목적
    1. 모듈의 존재 이유: 실행 중에 제대로 동작하는 것
    2. 변경을 위해 존재하는 것(간단한 작업만으로 변경이 가능해야 한다.)
    3. 코드를 읽는 사람과 의사소통하는 것

변경 용이성과 읽는 사람과의 의사소통이라는 목적은 만족시키지 못한다.

---

### Theater 클래스의 enter 메서드
문제: 관람객과 판매원이 소극장의 통제를 받는 수동적인 존재라는 점

이해 가능한 코드: 그 동작이 우리의 예상에서 크게 벗어나지 않는 코드

이 코드는 하나의 클래스나 메서드에서 너무 많은 세부사항을 다룬다.
-> 코드를 작성하는 사람뿐만 아니라, 코드를 읽고 이해하는 사람 모두에게 큰 부담을 준다.

- 가장 심각한 문제: Audience와 TicketSeller를 변경할 경우, Theater도 함께 변경해야 한다는 것


객체지향 설계: 서로 의존하면서 협력하는 객체들의 공동체를 구축하는 것
목표: 애플리케이션 기능을 구현하는데 필요한 **최소한의 의존성만 유지하고 불필요한 의존성만 유지하고
불필요한 의존성을 제거하는 것**

P17
설계의 목표: 객체 사이의 결합도를 낮춰 변경이 용이한 설계를 만드는 것

p18
해결 방법: Theater가  Audience와 TicketSeller의 세세한 부분까지 알지 못하도록 정보를 차단한다.
-> 관람객 스스로 가방 안의 현금과 초대장을 처리, 판매원이 스스로 매표소의 티켓, 판매 요금을 다루게 한다.


1. Theater의 enter 메서드에서 TicketOffice에 접근하는 모든 코드를 TicketSeller 내부로 숨긴다.
    - TicketSeller에 sellTo 메서드를 추가, Theater에 있던 로직을 sellTo 메서드로 옮기기

p20
     TicketSeller에서 getTicketOffic 메서드가 제거됨
     -> ticketOffice의 가시성이 private이고, 접근 가능한 퍼블릭 메서드가 존재하지 않는다.
     -> 외부에서는 ticketOffice에 직접 접근할 수 X!
     -> TicketSeller는 ticketOffice에서 티켓을 꺼내거나 판매 요금을 적립하는 일을  스스로 수행할 수 밖에 없다!
     
- 캡슐화: 개념적으로나 물리적으로 객체 내부의 세부적인 사항을 감추는 것
    
p27
변경하기 쉬운 설계: 한 번에 하나의 클래스만 변경할 수 있는 설계
해결 방법: 자신의 데이터를 스스로 처리하도록 프로세스의 적절한 단계를 Audience와 TicketSeller로 이동시키는 것

데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍하는 방식을 
`객체지향 프로그래밍(Object-Oriented Programming)`이라고 부른다.

훌륭한 객체지향 설계의 핵심: 캡슐화를 이용해서 의존성을 적절히 관리함으로써
객체 사이의 결합도를 낮추는 것

p28
`책임의 이동(shift of responsibility)`
각 객체는 **자신을 스스로 책임**진다.
ex) Theater에 몰려 있던 책임이 개별 객체로 이동한 것

- 데이터와 데이터를 사용하는 프로세스가 **별도의 객체**에 위치가 있다면, `절차적 프로그래밍`을 따르고 있을 확률이 높다.
- 데이터와 데이터를 사용하는 프로세스가 **동일한 객체**에 위치가 있다면, `객체지향 프로그래밍`을 따르고 있을 확률이 높다.

p29
객체가 어떤 데이터를 가지느냐보다는 **객체에 어떤 책임을 할당할 것이냐**에 초점을 맞춰야 한다.

설계를 어렵게 만드는것은 `의존성`
해결 방법: 불필요한 `의존성`을 제거 -> 객체 사이의 `결합도`를 낮춘다.

훌륭한 객체지향 설계
: 불필요한 세부사항을 캡슐화하는 자율적인 객체들이 낮은 결합도와 높은 응집도를 가지고 협력하도록
최소한의 의존성만을 남기는 것

